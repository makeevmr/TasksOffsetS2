# Matrix Lab

В рамках импортозамещения необходимо разработать программное обеспечение, позволяющее производить вычисления с матрицами.
Элементами матрицы могут быть рациональные числа, у которых числитель и знаменатель — длинные целые. 

Для записи команд в разрабатываемом языке матричных вычислений используется кембриджская префиксная нотация (это польская нотация со скобками). 
В префиксной записи оператор располагается слева от операндов, но так как у операторов и функций может быть разное количество операндов, аргументов, то в записи используются круглые скобки, чтобы избежать неоднозначности при интерпретации.

Например, функция от трех аргументов `FUNC(x, y, z)` запишется как
```
(FUNC x y z)
``` 
А оператор сложения (сложение `A` и `B`) запишется как 
```
(+ A B)
```
Аргументами функций и операторов могут быть переменные, константы и другие функции. Например, выражение `FUNC(x, y, z) + FUNC(a, 1, 2)` запишется как 
```
(+ (FUNC x y z) (FUNC a 1 2))
```

Для имен переменных будут использоваться только буквы английского алфавита (большие и маленькие) и цифры (не может быть первой цифры в имени переменной). 
Имя переменной (идентификатор) может содержать до 31-го символа. 

Должны поддерживаться следующие операторы и функции:
* `(= var value)` — присваивание переменной `var` значения `value`,
* `(+ A B)` — сложение *A+B*,
* `(- A B)` — вычитание *A-B*,
* `(.* A B)` — поэлементное умножение матриц *A* и *B* одинакового размера (получается матрица такого же размера как матрица *A* с элементами a<sub>ij</sub> * b<sub>ij</sub>),
* `(./ A B)` — поэлементное деление матриц *A* и *B* одинакового размера (получается матрица такого же размера как матрица *A* с элементами a<sub>ij</sub> / b<sub>ij</sub>),
* `(* A B)` — матричное умножение *A \* B*,
* `(/ A B)` — матричное деление *A \* B*<sup>-1</sup>,
* `(- A)` — унарный минус,
* `(zeros n m)` — матрица из нулей размером *n* строк и *m* столбцов,
* `(ones n m)` — матрица из единиц размером *n* строк и *m* столбцов,
* `(eye n)` — единичная матрица *n x n*,
* `(linspace x0 x1 n)` — создание вектора строки с *n* элементами от *x0* до *x1*,
* `(vertcat A1 A2 ... An)` — конкатенация матриц вертикально,
* `(horzcat A1 A2 ... An)` — конкатенация матриц горизонтально,
* `(transpose A)` — транспонирование матрицы,
* `(det A)` — вычисление определителя матрицы,
* `(inv A)` — вычисление обратной матрицы,
* `(sum A)` — вычисление суммы всех элементов матрицы,
* `(prod A)` — вычисление произведения всех элементов матрицы,
* `(min A B)` — для матриц A и В равных размеров вычисление матрицы такого же размера, элементами которой будут минимальные из соответствующих элементов матриц A и В,
* `(max A B)` — для матриц A и В равных размеров вычисление матрицы такого же размера, элементами которой будут максимальные из соответствующих элементов матриц A и В,
* `(disp A)` — вывод значения *A* в выходной файл.

Аргументы: имя входного файла и имя выходного файла. 

Во входном файле содержится программа — скрипт на языке матричных вычислений. Команды записаны в скрипте, каждая в отдельной строке.

Если в выражениях во входном файле содержится ошибка, то в выходной файл записывается `Error in line X`, где `X` — номер строки во входном файле (нумерация строк с 1).

## Вывод значений
Результат работы команды `(disp A)`.

Если выводимое значение `A` является скаляром, то необходимо вывести `имя_переменной` `пробел` `=` `пробел` `значение_переменной`.
Если значение целое число, то вывести как целое число (не выводить знаменатель). Если значение рациональная дробь, то вывести `числитель` `/` `знаменатель`. 
Для чисел меньше нуля знак выводить с числителем.

Если выводимое значение `A` является матрицей (вектором), то необходимо вывести в первой строке `имя_переменной` `пробел` `=` `пробел` `[`.
Во второй и далее строках вывести построчно матрицу, выравнивая столбцы по правому краю.
Последняя строка содержит один символ: `]`.

Если команде `disp` в качестве аргумента передано выражение, а не переменная (то есть команда `(disp (выражение))`), то в качестве имени переменной использовать `ans`.
