# Архиватор
Необходимо реализовать архиватор, который поддерживает преобразование MTF (Move-To-Front), алгоритм сжатия LZ77 и алгоритм Хаффмана.

## Преобразование Move-To-Front
Move-To-Front (MTF) — преобразование для кодирования данных, разработанное для улучшения производительности алгоритмов кодирования. 

Преобразование заменяет последовательность входных символов на последовательность целых чисел.

Основной идеей преобразования является замена каждого входного символа его номером в специальном стеке недавно использованных символов. 
Последовательности идентичных символов, к примеру, будут заменены (начиная со второго символа) на последовательность нулей. 
Если же символ долго не появлялся во входной последовательности, он будет заменён большим числом. 

Изначально каждое возможное значение байта записывается в список, в ячейку с номером, равным значению байта, т.е. (0, 1, 2, 3, …, 255). 
В процессе обработки данных этот список изменяется. 
Первый обработанный символ заменяется самим собой, после чего элемент, соответствующий этому символу, перемещается в голову списка (сдвигая элементы с 0 по своё положение на 1 вправо). 
Последующие символы кодируются номером элемента, содержащего их значение. 
После кодирования каждого символа эти элементы также продвигаются к голове списка.

### Пример
Рассмотрим работу алгоритма на примере строки `bananaaa`.

Строка будет преобразована в последовательность (записано в десятичной системе счисления): `98 98 110 1 1 1 0 0`.

Изначально в таблице ASCII символ `a` имеет код 97, символ `b` — код 98, а символ `n` — 110-ый в таблице. 
* После перемещения символа `b` в начало списка, символ `b` станет нулевым, а символ `a` станет 98-м.
* Далее, после перемещения символа `a` в начало списка, символ `a` станет нулевым, символ `b` станет 1-м, а символ `n` останется на позиции 110. 
* После перемещения символа `n` в начало списка, символ `n` станет нулевым, символ `a` станет 1-м, а символ `b` станет 2-м. 
* И так далее.

## Алгоритм сжатия LZ77

LZ77 — алгоритм сжатия без потерь, опубликованный Абрахамом Лемпелем и Якобом Зивом в 1977. 
Часто в кодируемых строках содержатся совпадающие длинные подстроки. 
В основе LZ77 лежит идея, заключающаяся в замене повторений на ссылки на позиции в тексте, где такие подстроки уже встречались.

Информацию о повторении можно закодировать парой чисел — смещением назад от текущей позиции (offset) и длиной совпадающей подстроки (length). 
Алгоритм LZ77 кодирует ссылки блоками из трёх элементов — `(offset, length, next)`. Параметр `next`  означает первый символ после найденного совпадающего фрагмента. 
Если LZ77 не удалось найти совпадение, то считается, что `offset=0` и `length=0`.

Для эффективного поиска повторов в LZ77 применяется метод «скользящего окна» — совпадения ищутся не на всём обработанном префиксе, а в небольшом буфере, состоящем из последних обработанных символов. 

Для хранения значений offset и length будем использовать по одному байту. Таким образом, буфер будем брать длиной 128 символов. Примечание: обычно длину буфера берут равной 2, 4 или 32KB.

### Пример
Рассмотрим пример кодирования на строке `abacabacabadaca` с буфером размера 5.

|Буфер | Строка          | Совпадение | Код     | Примечание                                                        | 
|-----:| --------------- | ---------- | ------- | ----------------------------------------------------------------- | 
|      | abacabacabadaca |            | (0,0,a) | Буфер сначала пуст                                                | 
|    a | bacabacabadaca  |            | (0,0,b) | В буфере нет `b`, значит нет совпадений                           | 
|   ab | acabacabadaca   | a          | (2,1,c) |                                                                   | 
| abac | abacabadaca     | abacaba    | (4,7,d) | length может быть более offset                                    | 
|cabad | aca             | a          | (2,1,c) |                                                                   | 
|badac | a               | a          | (2,1, ) | После символа `a` строка заканчивается, поэтому next не определен | 

Результатом кодирования является список полученных троек: `(0,0,a) (0,0,b) (2,1,c) (4,7,d) (2,1,c) (2,1, )`

## Алгоритм Хаффмана

Алгоритм Хаффмана — жадный алгоритм оптимального префиксного кодирования алфавита с минимальной избыточностью. 

Состоит из двух основных этапов. 
Алгоритм Хаффмана на входе получает таблицу частотностей символов в сообщении. 
Далее на основании этой таблицы строится дерево кодирования Хаффмана.

1. Символы входного алфавита образуют список свободных узлов. Каждый лист имеет вес, который может быть равен либо вероятности, либо количеству вхождений символа в сжимаемое сообщение.
2. Выбираются два свободных узла дерева с наименьшими весами.
3. Создается их родитель с весом, равным их суммарному весу.
4. Родитель добавляется в список свободных узлов, а два его потомка удаляются из этого списка.
5. Одной дуге, выходящей из родителя, ставится в соответствие бит 1, другой — бит 0. Битовые значения ветвей, исходящих от корня, не зависят от весов потомков.
6. Шаги, начиная со второго, повторяются до тех пор, пока в списке свободных узлов не останется только один свободный узел. Он и будет считаться корнем дерева.

### Пример
Пусть у нас есть сообщение в котором встречаются только 5 разных символов: `ABCDEAABBCDAE...`

Пусть символы в сообщении встречаются:
* A — 16 раз
* B — 8 раз
* C — 7 раз
* D — 6 раз
* E — 5 раз

Тогда коды Хаффмана символов будут выглядеть следующим образом:

* A — `0`
* B — `100`
* C — `101`
* D — `110`
* E — `111`

И исходное сообщение будет кодироваться потоком бит: `0100101110111001001001011100111...`

Поскольку ни один из полученных кодов не является префиксом другого, они могут быть однозначно декодированы при чтении их из потока. Кроме того, наиболее частый символ сообщения `A` закодирован наименьшим количеством бит.

## Требования к реализации

* Название програмы: `compress`
* Ключ `-mtf` — применение алгоритма MTF к входным данным.
* Ключ `-lz77` — сжатие алгоритмом LZ77.
* Ключ `-huffman` — кодирование информации алгоритмом Хаффмана.
* Ключ `-d` — декомпрессия файла.
* Ключ `-h` или `?` — вывод помощи на экран.

Архиватор может быть вызван с одним или несколькими ключами. Если указаны какие-то из ключей сжатия, то всегда первым применяется алгоритм MTF (если указан ключ `-mtf`),
далее применяется алгоритм LZ77 (если указан ключ `-lz77`), в конце применяется кодирование алгоритмом Хаффмана (если указан ключ `-huffman`).

Информация о способе сжатия должна быть сохранена в первом байте выходного файла. 
* Информация об использовании при сжатии метода MTF хранится в первом бите (первый бит равен 1, если MTF применялся, иначе равен 0).
* Информация об использовании при сжатии метода LZ77 хранится во втором бите (второй бит равен 1, если LZ77 применялся, иначе равен 0).
* Информация об использовании при сжатии алгоритма LZ77 хранится в третьем бите (третий бит равен 1, если алгоритм Хаффмана применялся, иначе равен 0).

Например, если первый байт файла имеет значение:
* 1, то применялся алгоритм MTF;
* 2 — применялся алгоритм LZ77;
* 4 — применялся алгоритм Хаффмана;
* 5 — применялся метод MTF и осуществлялось кодирование алгоритмом Хаффмана;
* 7 — сжате осуществлялось методами MTF-LZ77-Хаффман.

## Примеры вызова архиватора
* Вызов `compress -mtf input output` применяет алгоритм MTF к файлу *input* и записывает результат в файл *output*.
* Вызов `compress -lz77 input output` осуществляет сжатие файла *input* методом LZ77 и записывает результат в файл *output*.
* Вызов `compress -huffman input output` осуществляет сжатие файла *input* алгоритмом Хаффмана и записывает результат в файл *output*.
* Вызов `compress -mtf -lz77 input output` применяет алгоритм MTF к файлу *input*, осуществляет сжатие полученного методом LZ77 и записывает результат в файл *output*.
* Вызов `compress -lz77 -huffman input output` осуществляет сжатие файла *input* методом LZ77, применяет к полученному кодирование алгоритмом Хаффмана и записывает результат в файл *output*.
* Вызов `compress -lz77 -mtf -huffman input output` осуществляет сжатие файла *input* последовательно методами MTF, LZ77, кодирует алгоритмом Хаффмана и записывает результат в файл *output*.
* Вызов `compress -d input output` осуществляет декомпрессию  файла *input* и записывает результат в файл *output*.
* Вызов `compress -h` или `compress ?` выводит на экран помощь по использованию программы.


## Дополнительная литература
* [Рафгарден Тим. Совершенный алгоритм. Жадные алгоритмы и динамическое программирование. — СПб.: Питер, 2020. — 256 с.](https://ibooks.ru/bookshelf/367982) Глава 14. Коды Хаффмана. (Прим. При входе в библиотеку выберите организацию из списка "СПбГУ", и используйте вашу единую учетную запись).
* Кормен, Томас Х., Лейзерсон, Чарльз И., Ривест, Рональд Л., Штайн, Клиффорд. Алгоритмы: построение и анализ, 2-е издание. : Пер. с англ. — М. : Издательский дом “Вильямс”, 2011. — с. 459—466.

